---
layout: post
title: 学习-Java核心技术卷II
date: 2022/3/22
updated: 2022/3/22
cover: /assets/corejavaII.webp
# coverWidth: 920
# coverHeight: 613
comments: true
categories: 
- 技术
tags:
- 学习笔记
- Java
---

## 1. Java 8 的流库
### 1.1 从迭代到流的操作
流遵循了“做什么而非怎么做”的原则。
**流与集合之间的显著差异：**
1. 流并不存储其元素。这些元素可能存储在底层的集合中，或者是按需生成的。
2. 流的操作不会修改其数据源。
3. 流的操作是尽可能惰性执行的。

**操作流时的工作流程：**
1. 创建一个流
2. 指定将初始流转换为其他流的中间操作，可能包含多个步骤
3. 应用终止操作，从而产生结果。这个操作会强制执行之前的惰性操作。从此之后，这个流就再也不能用了。

### 1.2 流的创建
```java
Stream<String> words = Stream.of(contents.split("\\PL+"));
```

### 1.3 filter、map 和 flatMap 方法
流的转换会产生一个新的流，它的元素派生自另一个流中的元素。

### 1.4 抽取子流和组合流


### 1.5 其他的流转换


### 1.6 简单约简
约简是一种终结操作，他们会将流约简为可以在程序中使用的非流值。

### 1.7 Optional 类型
Option<T> 对象是一种包装器对象，要么包装了类型 T 的对象，要么没有包装任何对象。
- 获取 Optional 值
- 消费 Optional 值
- 管道化 Optional 值
- 不适合使用 Optional 值的方式
- 创建 Optional 值
- 用 flatMap 构建 Optional 值的函数
- 将 Optional 转换为流


### 1.8 收集结果
调用 iterator 方法或调用 forEach 方法

### 1.9 收集到映射表中


### 1.10 群组和分区


### 1.11 下流收集器


### 1.12 约简操作


### 1.13 基本类型流
IntStream、LongStream、DoubleStream......

### 1.14 并行流
1. 并行话会导致大量的开销，只有面对非常大的数据集才划算。
2. 只有在底层的数据源可以被有效的分割为多个部分时，将流并行话才有意义。
3. 并行流使用的线程池可能会因诸如文件 I/O 或网络访问这样的操作被阻塞而饿死。

**只有面对海量的内存数据和运算密集处理，并行流才会工作最佳。**

## 2. 输入与输出
### 2.1 输入/输出流
在 Java API 中可以从其中读入一个字节序列的对象称作输入流，而可以向其中写入一个字节序列的对象称作输出流。

- 读写字节
`int read()`
`void write()`

- 完整的流家族
见书 图2-1

- 组合输入/输出流过滤器


- 文本输入与输出

- 如何写出文本输出
`PrintWriter`

- 如何读入文本输入
- 以文本格式存储对象
- 字符编码方式


### 2.2 读写二进制数据
- DataInput 和 DataOutput
- 随机访问文件
- ZIP 文档

### 2.3 对象输入/输出流与序列化
- 保存和加载序列化对象
- 理解对象序列化的文件格式
- 修改默认的序列化机制
- 序列化单例和类型安全的枚举
- 版本管理
- 为克隆使用序列化

### 2.4 操作文件
- Path
- 读写文件
- 创建文件和目录
- 复制、移动和删除文件
- 获取文件信息
- 访问目录中的项
- 使用目录流
- ZIP 文件系统

### 2.5 内存映射文件
- 内存映射文件的性能
- 缓冲区数据结构

### 2.6 文件锁机制
请记住，文件加锁机制是依赖于操作系统的，下面是需要注意的几点：
1. 在某些系统中，文件加锁仅仅是建议性的，如果一个应用未能得到锁，它仍旧可以向被另一个应用并发锁定的文件执行写操作。
2. 在某些系统中，不能在锁定一个文件的同时将其映射到内存中。
3. 文件锁是由整个 Java 虚拟机持有的。
4. 在一些系统中，关闭一个通道会释放由 Java 虚拟机持有的底层文件上的所有锁。因此，在同一个锁定文件上应避免使用多个通道
5. 在网络文件系统上锁定文件是高度依赖于系统的。


### 2.7 正则表达式 
- 正则表达式语法
- 匹配字符串
- 找出多个匹配
- 用分隔符来分割
- 替换匹配


## 3. XML
### 3.1 XML 概述
**XML 与 HTML 的区别：**
1. 与HTML不同，XML 是大小写敏感的。
2. 在 XML 中结束标签绝对不能省略。
3. 在 XML 中，只有单个标签而没有相对应的结束标签的元素必须以 / 结尾。
4. 在 XML 中，属性值必须用引号括起来。
5. 在 XML 中，所有属性必须都有属性值。

### 3.2 XML 文档的结构
```xml
<?xml version="1.0" encoding="UTF-8"?>
```

文档头之后通常是文档类型定义（DTD）
最后，XML 文档的正文包含根元素，根元素包含其他元素。
元素可以有子元素、文本或两者皆有。

### 3.3 解析 XML 文档

### 3.4 验证 XML 文档
- 文档类型定义
- XML Schema
- 一个实践示例

### 3.5 使用 XPath 来定位信息

### 3.6 使用命名空间

### 3.7 流机制解析器
- 使用 SAX 解析器
- 使用 StAX 解析器

### 3.8 生成 XML 文档
- 不带命名空间的文档
- 带命名空间的文档
- 写出文档
- 使用 StAX 写出 XML 文档
- 示例：生成 SVG 文件

### 3.9 XSL 转换

## 4. 网络
### 4.1 连接到服务器
- 使用 telnet
- 用 Java 连接到服务器
- 套接字超时
- 因特网地址

### 4.2 实现服务器
- 服务器套接字
- 为多个客户端服务
- 半关闭
- 可中断套接字

### 4.3 获取 Web 数据
- URI 和 URL
	URI 是个纯粹的语法结构，包含用来指定 Web 资源的字符串的各种组成部分。URL 是 URI 的一个特例，它包含了用于定位 Web 资源的足够信息。
	
- 使用 URLConnection 获取信息
- 提交表单数据

### 4.4 HTTP 客户端

### 4.5 发送 E-mail 

## 5. 数据库编程
### 5.1 JDBC 的设计
- JDBC 驱动程序类型
- JDBC 的典型用法

### 5.2 结构化查询语言

### 5.3 JDBC 配置
- 数据库URL
- 驱动程序 JAR 文件
- 启动数据库
- 注册驱动器类
- 连接到数据库

### 5.4 使用 JDBC 语句
- 执行 SQL 语句
- 管理连接、语句和结果集
- 分析 SQL 异常
- 组装数据库

### 5.5 执行查询操作
- 预备语句
- 读写 LOB
- SQL 转义
- 多结果集
- 获取自动生成的键

### 5.6 可滚动和可更新的结果集
- 可滚动的结果集
- 可更新的结果集

### 5.7 行集
- 构建行集
- 被缓存的行集

### 5.8 元数据

### 5.9 事务
- 用 JDBC 对事务编程
- 保存点
- 批量更新
- 高级 SQL 类型

### 5.10 Web 和企业应用中的连接管理

## 6. 日期和时间 API
### 6.1 时间线

### 6.2 本地日期

### 6.3 日期调整器

### 6.4 本地时间

### 6.5 时区时间

### 6.6 格式化和解析

### 6.7 与遗留代码的互操作

## 7. 国际化
### 7.1 locale
- 为什么需要 locale
- 指定 locale
- 默认 locale
- 显示名字

### 7.2 数字格式
- 格式化数字值
- 货币

### 7.3 日期和时间

### 7.4 排序和规范化

### 7.5 消息格式化
- 格式化数字和日期
- 选择格式

### 7.6 文本输入和输出
- 文本文件
- 行结束符
- 控制台
- 日志文件
- UTF-8 字节顺序标志
- 源文件的字符编码

### 7.7 资源包
- 定位资源包
- 属性文件
- 包类

### 7.8 一个完整的例子

## 8. 脚本、编译与注解处理
### 8.1 Java平台的脚本机制
- 获取脚本引擎
- 脚本计算与绑定
- 重定向输入与输出
- 调用脚本的函数和方法
- 编译脚本
- 示例：用脚本处理 GUI 事件

### 8.2 编译器 API
- 调用编译器
- 发起编译任务
- 捕获诊断消息
- 从内存中读取源文件
- 将字节码写出到内存中
- 示例：动态 Java 代码生成

### 8.3 使用注解
- 注解简介
- 示例：注解事件处理器

### 8.4 注解语法
- 注解接口
- 注解
- 注解各类声明
- 注解类型用法
- 注解 this

### 8.5 标准注解
- 用于编译的注解
- 用于管理资源的注解
- 元注解

### 8.6 源码级注解处理
- 注解处理器
- 语言模型 API
- 使用注解来生成源码

### 8.7 字节码工程
- 修改类文件
- 在加载时修改字节码


## 9. Java 平台模块系统
### 9.1 模块的概念
### 9.2 对模块命名
### 9.3 模块化的 “Hello World” 程序
### 9.4 对模块的需求
### 9.5 导出包
### 9.6 模块的 JAR
### 9.7 模块和反射式访问
### 9.8 自动模块
### 9.9 不具名模块
### 9.10 用于迁移的命令行标志
### 9.11 传递的需求和静态的需求
### 9.12 限定导出和开放
### 9.13 服务加载
### 9.14 操作模块的工具

## 10. 安全
### 10.1 类加载器
- 类加载过程
- 类加载器的层次结构
- 将类加载器用作命名空间
- 编写你自己的类加载器
- 字节码校验

### 10.2 安全管理器与访问权限
- 权限检查
- Java 平台安全性
- 安全策略文件
- 定制权限
- 实现权限类

### 10.3 用户认证
- JAAS 框架
- JAAS 登录模块

### 10.4 数字签名
- 消息摘要
- 消息签名
- 校验签名
- 认证问题
- 证书签名
- 证书请求
- 代码签名

### 10.5 加密
- 对称密码
- 密钥生成
- 密码流
- 公共密钥密码

## 11. 高级 Swing 和图形化编程

## 12. 本地方法
### 12.1 从 Java 程序中调用 C 函数

### 12.2 数值参数与返回值

### 12.3 字符串参数

### 12.4 访问域
- 访问实例域
- 访问静态域

### 12.5 编码签名

### 12.6 调用 Java 方法
- 实例方法
- 静态方法
- 构造器
- 另一种方法调用

### 12.7 访问数组元素

### 12.8 错误处理

### 12.9 使用调用 API

### 12.10 完整的示例：访问 Windows 注册表
- Windows 注册表概述
- 访问注册表的 Java 平台接口
- 以本地方法实现注册表访问函数

